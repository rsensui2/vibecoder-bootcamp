# 今更聞けないシリーズ - AI駆動開発の基本操作

**最終更新日**: 2025-12-18

このドキュメントは、「基本すぎて今更聞けない」けれど実は重要な操作や概念をまとめたものです。AI駆動開発を始める際に、多くの人が最初につまずくポイントを丁寧に解説します。

---

## プロジェクトフォルダとアプリのルートディレクトリの違い

開発を始めるとき、**2つの重要なフォルダ**を理解する必要があります。

### 1. プロジェクトフォルダ（Cursorで開くフォルダ）

**プロジェクトフォルダ**とは、プロジェクト全体が入っている**最上位のフォルダ**のことです。

```
my-project/                    ← これがプロジェクトフォルダ（Cursorで開く）
├── docs/                      ← ドキュメント
├── app/                       ← Next.jsアプリ本体
│   ├── src/
│   ├── public/
│   ├── package.json          ← アプリのpackage.json
│   └── ...
├── backend/                   ← バックエンド（別のアプリ）
│   ├── package.json
│   └── ...
└── README.md
```

**プロジェクトフォルダの役割**:
- Cursorで「Open Folder」するのはここ
- AIエージェントがプロジェクト全体を理解できる
- ファイル検索が正しく動作する
- 複数のアプリやドキュメントをまとめて管理

### 2. アプリのルートディレクトリ（コマンドを実行するフォルダ）

**アプリのルートディレクトリ**とは、実際にアプリケーションが入っているフォルダで、**`package.json` があるフォルダ**のことです。

```
my-project/
├── docs/
├── app/                       ← これがアプリのルートディレクトリ
│   ├── package.json          ← npm run dev を実行する場所
│   ├── src/
│   └── ...
```

**アプリのルートディレクトリの役割**:
- `npm run dev` などのコマンドを実行する場所
- ターミナルで移動する先
- `.env.local` を配置する場所

### よくあるプロジェクト構造のパターン

#### パターン1: シンプルな構造（プロジェクトフォルダ = アプリのルート）

```
my-next-app/                   ← プロジェクトフォルダ = アプリのルート
├── app/
├── components/
├── package.json              ← ここで npm run dev
└── ...
```

この場合、Cursorで `my-next-app` を開けば、すぐに `npm run dev` が実行できます。

#### パターン2: 複数アプリやドキュメントがある構造

```
my-project/                    ← プロジェクトフォルダ（Cursorで開く）
├── docs/
├── frontend/                  ← フロントエンドのアプリ
│   ├── package.json          ← ここで npm run dev (frontend用)
│   └── ...
├── backend/                   ← バックエンドのアプリ
│   ├── package.json          ← ここで npm start (backend用)
│   └── ...
└── README.md
```

この場合：
1. Cursorで `my-project` を開く（プロジェクト全体）
2. ターミナルで `cd frontend` に移動
3. `npm run dev` を実行

### なぜこの区別が重要なのか

**Cursorで開くフォルダ**と**コマンドを実行するフォルダ**は異なる場合があります。

- **Cursorで開く** → プロジェクト全体（AIが全体を理解）
- **ターミナルで移動** → アプリのルート（コマンドを実行）

この違いを理解していないと：
- `npm run dev` を実行しても「package.json が見つからない」エラー
- 環境変数ファイル（`.env.local`）を間違った場所に作成
- AIが正しいファイル構造を理解できない

### 正しい開発の流れ

1. **Cursorでプロジェクトフォルダを開く**
   - 「File」→「Open Folder...」
   - プロジェクト全体のフォルダを選択

2. **ターミナルでアプリのルートディレクトリに移動**
   - `ls` でフォルダ一覧を確認
   - `cd app` など、`package.json` があるフォルダに移動
   - `ls` で `package.json` があることを確認

3. **コマンドを実行**
   - `npm run dev` などを実行

**重要**: 個別のファイルを開くのではなく、必ず**プロジェクトフォルダごと**Cursorで開いてください。

---

## ターミナルの現在地を理解する

### ターミナルは「今どこにいるか」が重要

ターミナルでコマンドを実行するとき、必ず「どのフォルダにいるか」が影響します。例えば `npm run dev` は、`package.json` があるフォルダ（プロジェクトのルートディレクトリ）で実行しないとエラーになります。

### 現在地の確認方法

ターミナルを開くと、通常は現在地が表示されています：

```bash
username@MacBook my-next-app %
```

この場合、`my-next-app` フォルダにいることが分かります。

もし表示が分かりにくい場合は、`pwd` コマンドで確認できます：

```bash
pwd
# 出力例: /Users/username/projects/my-next-app
```

### 正しいフォルダに移動する方法

#### 方法1: `cd` コマンドで移動

```bash
# プロジェクトフォルダに移動
cd /Users/username/projects/my-next-app

# または相対パスで
cd my-next-app
```

#### 方法2: Cursorの機能を使う（おすすめ）

1. 左側のファイルツリーで、目的のフォルダを右クリック
2. 「統合ターミナルで開く」を選択
3. そのフォルダで新しいターミナルが開く

この方法なら、確実に正しいフォルダでターミナルを開けます。

### ターミナルは複数開ける

ターミナルは複数のタブで開くことができます。ターミナルペインの右上に「+」ボタンがあり、クリックすると新しいターミナルが開きます。

不要なターミナルは、タブの「×」ボタンで閉じることができます。整理整頓のために、使っていないターミナルは適宜削除しましょう。

---

## Cursorチャットへのファイル追加方法

AIエージェントにファイルの内容を見せたいとき、チャットにファイルを追加する必要があります。方法は2つあります。

### 方法1: `@` でファイル名を指定

1. 右側のチャットペインでメッセージを入力
2. **半角の `@` を入力**
3. ファイル名を入力すると、候補が表示される
4. 候補から選択して追加

```
@app/page.tsx このページにボタンを追加してください
```

この方法は、ファイル名が分かっているときに便利です。

### 方法2: ドラッグ&ドロップ

1. 左側のファイルツリーからファイルを選択
2. 右側のチャットペインに**ドラッグ&ドロップ**
3. ファイルが追加される

この方法は、ファイルツリーを見ながら直感的に追加できるので便利です。

**複数ファイルを一度に追加**することもできます。`Cmd`（Mac）または `Ctrl`（Windows）を押しながら複数ファイルを選択してドラッグすればOKです。

---

## Markdownファイルのプレビュー表示

MarkdownファイルはREADMEやドキュメント作成によく使われます。Cursorでは、Markdownファイルを見やすく表示するプレビュー機能があります。

### プレビューの開き方（方法1）

1. Markdownファイルをエディターで開く
2. エディターにマウスカーソルがある状態で、`Shift + Cmd + V`（Mac）または `Shift + Ctrl + V`（Windows）を押す
3. プレビューが右側に表示される

### プレビューの開き方（方法2）

1. ファイルツリーでMarkdownファイルを右クリック
2. 「プレビューで開く」を選択
3. プレビューが表示される

プレビューモードでは、実際にどう表示されるかを確認しながら編集できます。エディターとプレビューを並べて表示することもできます。

---

## Finderでファイルの場所を確認する

Cursor内でファイルを見ているとき、「このファイルって実際どこに保存されているの？」と確認したくなることがあります。

### Finderで開く方法

1. ファイルツリーでファイルまたはフォルダを右クリック
2. **「Reveal in Finder」**（Mac）または **「Reveal in Explorer」**（Windows）を選択
3. Finder/Explorerが開き、そのファイルの場所が表示される

これは、ファイルをコピーしたり、別のアプリで開いたりするときに便利です。

---

## ターミナルの表示/非表示と基本操作

### ターミナルの表示/非表示

ターミナルは `Cmd + J`（Mac）または `Ctrl + J`（Windows）で表示・非表示を切り替えられます。

画面を広く使いたいときは非表示にし、コマンドを実行するときに表示します。

### 実行中のコマンドを停止する

開発サーバー（`npm run dev` など）を起動している状態で、それを止めたいときがあります。

**停止方法**: `Ctrl + C`

- Macでも **`Ctrl + C`** です（`Cmd`ではありません）
- Windowsでも **`Ctrl + C`** です（コピーと同じキーですが、ターミナルでは「停止」の意味になります）

ターミナルで `Ctrl + C` を押すと、現在実行中のプロセス（コマンド）が終了します。

### 前に実行したコマンドを呼び出す

ターミナルで何度も同じコマンドを打つのは面倒です。**矢印キーの `↑`（上）** を押すと、前に実行したコマンドが表示されます。

```bash
# 1回目
npm run dev

# 2回目以降
# ↑キーを押すだけで "npm run dev" が表示される
```

何度も `↑` を押すと、さらに前のコマンドまで遡れます。`↓` で戻ることもできます。

### ターミナルをクリアする

ターミナルに古いログやエラーメッセージがたくさん表示されていると、最新の情報が見づらくなります。

**クリア方法**: `clear` コマンド

```bash
clear
```

これでターミナルの表示内容がすべて消え、スッキリします。

---

## エラーメッセージをAIチャットに送る方法

バグが起きたとき、エラーメッセージをAIエージェントに見せると解決策を提案してくれます。しかし、古いエラーが残っていると、AIが混乱する可能性があります。

### 推奨される手順

1. **`Ctrl + C`** で実行中のサーバーを停止
2. **`clear`** でターミナルをクリア（古いエラーを消す）
3. **`npm run dev`** で開発サーバーを再起動
4. エラーが再現されるか確認
5. ターミナル全体を選択:
   - `Cmd + A`（Mac）または `Ctrl + A`（Windows）でターミナル内容を全選択
   - または必要な部分だけマウスで選択
6. **`Cmd + L`（Mac）/ `Ctrl + L`（Windows）** でCursorチャットを開く
7. 「Add to Chat」でエラーメッセージをチャットに追加
8. AIに質問する

この流れで、最新のエラーだけをAIに見せることができます。

### よくある間違い

❌ 古いエラーが残ったままチャットに送る → AIが間違った解決策を提案する可能性
✅ `clear` で古いエラーを消してから、最新のエラーを送る

---

## CursorのAIモデル選択

### なぜモデル選択が重要なのか

CursorのAIエージェントは、複数のAIモデルから選択できます。**使うモデルによって、コードの品質や生産性が大きく変わります**。適切なモデルを選ぶことが、AI駆動開発の成功の鍵です。

### VibeCoder育成プログラムの推奨設定

#### ❌ 避けるべき設定: Autoモード

Autoモードは自動でモデルを選んでくれますが、**推奨しません**。理由：
- 悪いモデルが選ばれることが多い
- エラー率が高くなる
- 生産性が下がる

無料で使えるメリットはありますが、学習効率を考えると避けるべきです。

#### ✅ 推奨設定: 状況に応じてモデルを切り替える

**基本モデル: Gemini 3 Flash**
- 日常的なコード生成や質問に使用
- 軽量で応答が速い
- ほとんどのタスクはこれで十分

**高度なモデル（複雑なタスクやバグ修正時）:**
- Gemini 3 Pro
- Claude Opus 4.5
- GPT 5.2
- その他のThinkingモデル

### いつモデルを切り替えるか

#### Gemini 3 Flashを使う場面
- 簡単なコード生成
- 基本的な質問
- シンプルなリファクタリング
- ドキュメント作成

#### 高度なモデルに切り替える場面
- Gemini 3 Flashで解決しない複雑な課題
- 複雑なバグの修正
- アーキテクチャ設計の相談
- 難易度の高いリファクタリング

### モデル切り替えの具体的な方法

1. チャットペイン上部のモデル名（例: "Gemini 3 Flash"）をクリック
2. ドロップダウンから使いたいモデルを選択
3. 選択したモデルでチャット開始

### 重要なポイント

- **簡単な操作には軽いモデル** → スピードが速い、コストが低い
- **複雑な操作には高度なモデル** → 精度が高い、エラーが少ない
- **AIの賢さ = 生産性、エラー率の低さ**
- **バージョンは日々更新される** → その時の最新モデルを使用

迷ったら、まずはGemini 3 Flashで試して、うまくいかなければ高度なモデルに切り替えるという流れがおすすめです。

---

## 開発サーバーの起動とブラウザアクセス

### `npm run dev` とは何か

`npm run dev` は、開発用のローカルサーバーを起動するコマンドです。このコマンドを実行すると：

1. **開発サーバーが起動する**
   - Next.jsアプリケーションがあなたのパソコン上で動き始めます
   - コードの変更を監視し、自動でリロードします（Hot Reload）

2. **ポート3000で待機**
   - 通常、`http://localhost:3000` でアクセスできるようになります
   - `localhost` = あなたのパソコン自身
   - `3000` = ポート番号（サーバーの入り口のようなもの）

3. **ターミナルに表示されるメッセージ**
   ```bash
   ➜  Local:   http://localhost:3000
   ➜  Network: http://192.168.x.x:3000
   ✓ Ready in 2.3s
   ```
   このような表示が出れば、起動成功です。

### ブラウザでアクセスする方法

#### 方法1: 自動で開く（推奨）

多くの場合、`npm run dev` を実行すると、自動的にブラウザが開いて `http://localhost:3000` にアクセスします。

#### 方法2: 手動でURLを入力

1. ブラウザ（Chrome、Safariなど）を開く
2. アドレスバーに `http://localhost:3000` と入力
3. Enterキーを押す

#### 方法3: ターミナルのリンクをクリック

Cursorのターミナルでは、表示された `http://localhost:3000` のリンクを **`Cmd + クリック`（Mac）** または **`Ctrl + クリック`（Windows）** でクリックすると、ブラウザが開きます。

### `localhost:3000` の意味

- **localhost**: あなたのパソコン自身を指す特別な名前
  - インターネット上の他のサーバーではなく、自分のパソコンにアクセスしている
  - 他の人からは見えない（自分だけがアクセスできる）

- **3000**: ポート番号
  - サーバーの「入り口」のようなもの
  - Next.jsのデフォルトは3000番ポート
  - 他のアプリが3000番を使っている場合、3001番などに自動で切り替わる

### サーバーが起動している状態とは

`npm run dev` を実行してサーバーが起動すると、ターミナルは「待機状態」になります。

```bash
➜  Local:   http://localhost:3000
# ここでカーソルが止まっている（新しいコマンドを受け付けない）
```

この状態は**正常**です。サーバーが動いている証拠です。

- **新しいコマンドを実行したい場合**: 新しいターミナルタブを開く（`+` ボタン）
- **サーバーを停止したい場合**: `Ctrl + C` を押す

### よくある質問

#### Q: `npm run dev` を実行しても何も表示されない

**確認すること**:
1. ターミナルの現在地が正しいか（プロジェクトのルートディレクトリにいるか）
2. `package.json` が存在するか
3. `npm install` を実行済みか

#### Q: `Port 3000 is already in use` と表示される

**原因**: 別のプロセスがポート3000を使用中

**解決策**:
```bash
# 別のポートで起動（例: 3001）
PORT=3001 npm run dev

# または、3000番を使っているプロセスを終了
# Macの場合
lsof -ti:3000 | xargs kill -9
```

#### Q: ブラウザで「このサイトにアクセスできません」と表示される

**確認すること**:
1. サーバーが起動しているか（ターミナルに `Ready` と表示されているか）
2. URLが `http://localhost:3000` で正しいか（`https://` ではなく `http://`）
3. ポート番号が正しいか（ターミナルの表示を確認）

---

## 環境変数と.env.localファイル

### 環境変数とは

環境変数とは、**アプリケーションの設定情報を外部に保存する仕組み**です。コードに直接書くのではなく、別ファイル（`.env.local`）に保存することで：

- **セキュリティ向上**: APIキーやパスワードをコードから分離
- **環境ごとの設定切り替え**: 開発環境と本番環境で異なる値を使用可能
- **秘密情報の保護**: Gitにコミットせず、秘密を守る

例えば、Supabaseの接続情報やClerkのAPIキーなどを環境変数で管理します。

### .env.localファイルの作り方

#### ステップ1: ファイルを作成

プロジェクトのルートディレクトリ（`package.json`と同じ階層）に `.env.local` というファイルを作成します。

**Cursorでの作成方法**:
1. ファイルツリーでプロジェクトルートを右クリック
2. 「New File」を選択
3. `.env.local` と入力して Enter

**重要**: ファイル名の先頭に `.`（ドット）を忘れずに！

#### ステップ2: キーとバリューを書く

`.env.local` の中身は、`キー名=値` の形式で書きます。

```bash
# .env.local の例

# Supabase設定
NEXT_PUBLIC_SUPABASE_URL=https://xxxxx.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJ...

# Clerk設定
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_xxxxx
CLERK_SECRET_KEY=sk_test_xxxxx
```

**書き方のルール**:
- `=` の前後にスペースは入れない
- `#` で始まる行はコメント（メモ）
- 値に空白が含まれる場合は `""` で囲む（通常は不要）

#### ステップ3: .gitignoreに追加（重要！）

`.env.local` は秘密情報を含むため、**Gitにコミットしてはいけません**。

`.gitignore` に以下を追加（Next.jsプロジェクトでは通常デフォルトで含まれています）:

```
# .gitignore
.env.local
```

### キーとバリューの説明

#### キー（Key）
環境変数の名前です。通常、大文字とアンダースコアで書きます。

例: `NEXT_PUBLIC_API_URL`、`DATABASE_URL`

#### バリュー（Value）
その環境変数に設定する値です。

例: `https://api.example.com`、`postgresql://localhost:5432/mydb`

### NEXT_PUBLIC_ プレフィックスの重要性

Next.jsでは、環境変数の名前に `NEXT_PUBLIC_` を付けるかどうかで、**使える場所が変わります**：

| プレフィックス | 使える場所 | 用途 |
|--------------|----------|------|
| **`NEXT_PUBLIC_`** | サーバー＆ブラウザ | ブラウザに公開してもOKな値（例: APIのURL） |
| **なし** | サーバーのみ | 秘密情報（例: APIキー、データベースパスワード） |

**重要**: APIキーなどの秘密情報には `NEXT_PUBLIC_` を**絶対に付けない**でください。ブラウザに公開され、誰でも見られてしまいます。

### 環境変数の使い方

#### サーバーコンポーネント（Server Component）

サーバーコンポーネントでは、**すべての環境変数**を使えます。

```typescript
// app/api/data/route.ts
export async function GET() {
  // どちらも使える
  const apiUrl = process.env.NEXT_PUBLIC_API_URL
  const secretKey = process.env.API_SECRET_KEY

  // ...
}
```

#### クライアントコンポーネント（Client Component）

クライアントコンポーネントでは、**`NEXT_PUBLIC_` が付いた環境変数のみ**使えます。

```typescript
'use client'

export default function MyComponent() {
  // ✅ OK: NEXT_PUBLIC_ が付いている
  const apiUrl = process.env.NEXT_PUBLIC_API_URL

  // ❌ NG: NEXT_PUBLIC_ が付いていないので undefined になる
  const secretKey = process.env.API_SECRET_KEY // undefined
}
```

### 環境変数が読み込まれない場合

#### 1. 開発サーバーを再起動

`.env.local` を変更したら、必ず開発サーバーを再起動してください。

```bash
# ターミナルで
Ctrl + C  # サーバー停止
npm run dev  # 再起動
```

#### 2. ファイル名が正しいか確認

- ✅ 正しい: `.env.local`
- ❌ 間違い: `env.local`（先頭の `.` が必要）
- ❌ 間違い: `.env.local.txt`（拡張子は付けない）

#### 3. プロジェクトルートに配置されているか確認

`.env.local` は `package.json` と同じ階層に配置する必要があります。

### セキュリティのベストプラクティス

1. **`.env.local` は絶対にGitにコミットしない**
2. **秘密情報には `NEXT_PUBLIC_` を付けない**
3. **`.env.example` でサンプルを提供**

`.env.example` の例:
```bash
# .env.example（これはGitにコミットしてOK）
NEXT_PUBLIC_SUPABASE_URL=your-supabase-url-here
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key-here
CLERK_SECRET_KEY=your-clerk-secret-key-here
```

チームメンバーや他の開発者は、この `.env.example` をコピーして `.env.local` を作成し、実際の値を入れます。

---

## よくやる操作の流れ

### バグ修正後の動作確認

1. コードを修正
2. `Ctrl + C` でサーバーを停止
3. `clear` でターミナルをクリア
4. `npm run dev` でサーバーを再起動
5. ブラウザで動作確認

この流れを何度も繰り返すことになるので、覚えておくとスムーズです。

---

## まとめ

これらの操作は「基本中の基本」ですが、最初は誰でもつまずきます。何度も繰り返すうちに自然と身につくので、焦らず練習しましょう。

分からないことがあれば、遠慮せずに質問してください。「今更聞けない」ことなんて、実は存在しません。
