# サブエージェントの設定と実装ガイド

**作成日**: 2025年11月8日
**対象**: VibeCoder育成プログラム
**前提知識**: [01_sub-agents-overview.md](01_sub-agents-overview.md)

---

## 📋 目次

1. [作成方法](#作成方法)
2. [設定ファイルの詳細](#設定ファイルの詳細)
3. [呼び出し方法](#呼び出し方法)
4. [実践的な設定例](#実践的な設定例)
5. [トラブルシューティング](#トラブルシューティング)
6. [ベストプラクティス](#ベストプラクティス)

---

## 作成方法

サブエージェントを作成する方法は3つあります。

### 方法1: `/agents` コマンド（推奨）

最も簡単で直感的な方法です。

#### ステップ1: `/agents` を実行

Claude Codeで `/agents` と入力します。

```
/agents
```

#### ステップ2: "Create New Agent" を選択

表示されたUIから「新規作成」を選びます。

#### ステップ3: スコープを選択

| スコープ | 保存場所 | 用途 |
|---------|---------|------|
| **Project** | `.claude/agents/` | プロジェクト固有<br/>チームで共有 |
| **User** | `~/.claude/agents/` | 個人用<br/>全プロジェクトで使用 |

**推奨**: チーム開発では **Project**、個人ツールは **User**

#### ステップ4: 作成方法を選択

##### A. Claudeに生成させる（推奨）

```
「TypeScriptコードのセキュリティレビューを行うエージェントを作成してください」
```

Claudeが自動的に:
- 適切な `name` を決定
- `description` を作成
- 必要な `tools` を選択
- システムプロンプトを記述

##### B. 手動で作成

- `name`: `security-reviewer`
- `description`: 入力
- `tools`: チェックボックスで選択
- "e"キーを押してエディタで編集

#### ステップ5: 保存

設定を保存すると、即座に使用可能になります。

---

### 方法2: ファイルを直接作成

#### ステップ1: ディレクトリを確認/作成

```bash
# プロジェクトレベル
mkdir -p .claude/agents

# ユーザーレベル
mkdir -p ~/.claude/agents
```

#### ステップ2: Markdownファイルを作成

```bash
# プロジェクトレベルの例
touch .claude/agents/code-reviewer.md
```

#### ステップ3: 内容を記述

```markdown
---
name: code-reviewer
description: TypeScriptコードのセキュリティとパフォーマンスをレビューする
tools: Read, Grep, Glob
model: sonnet
---

# コードレビューエージェント

あなたは10年以上の経験を持つシニアエンジニアです。

## レビュー観点

### 1. セキュリティ
- XSS脆弱性
- SQLインジェクション
- CSRF対策
- 認証・認可の不備

### 2. パフォーマンス
- 不要な再レンダリング
- メモリリーク
- 非効率なループ

### 3. 保守性
- 命名規則
- コメント
- 関数の長さ

## 出力形式

### 問題点
- [Critical] 具体的な問題
- [High] 重要な改善点
- [Medium] 推奨改善
- [Low] 細かい提案

### 改善案
具体的なコード例を提示
```

#### ステップ4: 確認

```bash
# ファイルが正しく作成されたか確認
cat .claude/agents/code-reviewer.md
```

---

### 方法3: CLIでワンタイム定義

セッション限定で使用する一時的なエージェント。

```bash
claude --agents '{
  "name": "temp-analyzer",
  "description": "一時的な分析エージェント",
  "tools": ["Read", "Grep"],
  "prompt": "データを分析して要約を作成してください"
}'
```

**使用場面**:
- 実験的なエージェント
- 一度きりのタスク
- プロトタイピング

**制限**:
- セッション終了で消える
- ファイルより優先度が低い

---

## 設定ファイルの詳細

### YAMLフロントマター

```yaml
---
name: エージェント名
description: いつ使うべきかの説明
tools: ツールのリスト
model: モデル指定
---
```

### フィールド詳細

#### 1. `name`（必須）

**役割**: エージェントの一意な識別子

**ルール**:
- ケバブケース推奨: `code-reviewer`（✅）
- スペース不可: `code reviewer`（❌）
- 同名エージェントは上書きされる

**例**:
```yaml
name: security-audit-specialist
```

#### 2. `description`（必須）

**役割**: 自動選択時の判断材料

**重要**: Claudeがこの説明を読んで、タスクに適したエージェントを選びます。

**悪い例**:
```yaml
description: コードを見る
```
→ 曖昧すぎて自動選択されにくい

**良い例**:
```yaml
description: Reactコンポーネントのパフォーマンス問題を特定し、useMemo/useCallbackの適用箇所を提案する
```
→ 具体的で、自動選択されやすい

**ベストプラクティス**:
- 動詞で始める: 「〜を行う」「〜を分析する」
- 対象を明確に: 「Reactコンポーネント」「REST API」
- 成果物を記述: 「提案する」「レポートする」

#### 3. `tools`（オプション）

**役割**: 使用可能なツールを制限

**省略時**: メインセッションの全ツールを継承

**指定方法**:
```yaml
# カンマ区切り
tools: Read, Grep, Glob, Bash

# 配列形式（YAML標準）
tools:
  - Read
  - Grep
  - Glob
  - Bash
```

**利用可能なツール一覧**:

| カテゴリ | ツール名 | 説明 |
|---------|---------|------|
| **ファイル操作** | `Read` | ファイル読み込み |
| | `Write` | ファイル書き込み |
| | `Edit` | ファイル編集 |
| | `Glob` | パターンマッチング検索 |
| | `Grep` | テキスト検索 |
| **実行** | `Bash` | シェルコマンド実行 |
| **Web** | `WebFetch` | URL取得 |
| | `WebSearch` | Web検索 |
| **MCP** | `mcp__*` | MCPサーバーのツール |
| **その他** | `Task` | サブタスク作成 |
| | `TodoWrite` | タスク管理 |

**セキュリティのベストプラクティス**:

```yaml
# ❌ 危険: 全ツール許可
tools:  # 省略 = 全て継承

# ✅ 安全: 最小権限
tools: Read, Grep  # 読み取りのみ
```

**実例**:

```yaml
# レビュー専用（書き込み不可）
tools: Read, Grep, Glob

# 実装可能（編集・実行可能）
tools: Read, Write, Edit, Bash

# サーバー起動専用
tools: mcp__tool-mcp__start_nextjs_server
```

#### 4. `model`（オプション）

**役割**: 使用するClaudeモデルを指定

**選択肢**:

| モデル | 特徴 | 用途 |
|-------|------|------|
| `inherit` | メインセッションと同じ（デフォルト） | 通常はこれ |
| `sonnet` | バランス型 | 汎用タスク |
| `opus` | 最高性能 | 複雑な推論 |
| `haiku` | 高速・低コスト | シンプルなタスク |

**使い分けの例**:

```yaml
# サーバー起動だけ → Haikuで十分
---
name: server-starter
model: haiku
tools: Bash
---

# 複雑なリファクタリング → Opus
---
name: complex-refactorer
model: opus
tools: Read, Edit, Write, Bash
---

# 通常のレビュー → Sonnet
---
name: code-reviewer
model: sonnet
tools: Read, Grep
---
```

---

### システムプロンプト

YAMLフロントマターの後に記述します。

#### 基本構造

```markdown
---
name: example-agent
description: 例示用エージェント
---

# エージェントの役割

あなたは〜です。

## タスク

1. 〜を行う
2. 〜を確認する
3. 〜を出力する

## 制約

- 〜してはいけない
- 〜を優先する

## 出力形式

```例```
```

#### 効果的なプロンプトの要素

##### 1. **役割定義**

```markdown
あなたは10年以上の経験を持つシニアセキュリティエンジニアです。
OWASP Top 10の深い知識を持ち、実践的な脆弱性診断を行います。
```

**効果**: AIがその専門家の視点で分析する

##### 2. **具体的な手順**

```markdown
## 分析手順

1. ファイル全体を読み込む
2. 認証・認可ロジックを特定
3. 入力検証の有無を確認
4. SQLクエリの構築方法をチェック
5. セッション管理を検証
6. レポートを作成
```

**効果**: 一貫性のある分析

##### 3. **制約とルール**

```markdown
## 制約

- ファイルの編集は絶対に行わない
- 推測ではなく、コードベースの事実のみを報告
- 重要度の高い問題を優先
```

**効果**: 予期しない動作を防止

##### 4. **出力フォーマット**

```markdown
## 出力形式

### [Critical] タイトル
**場所**: ファイル名:行番号
**問題**: 具体的な説明
**影響**: ビジネスへの影響
**対策**: 具体的なコード例

### [High] タイトル
...
```

**効果**: 一貫性のある読みやすい出力

##### 5. **例示**

````markdown
## 例

**悪いコード**:
```typescript
const query = `SELECT * FROM users WHERE id = ${req.params.id}`;
```

**改善後**:
```typescript
const query = 'SELECT * FROM users WHERE id = ?';
db.execute(query, [req.params.id]);
```
````

**効果**: 具体的な改善案を提示

---

## 呼び出し方法

サブエージェントを使用する方法は2つあります。

### 方法1: 自動選択（推奨）

Claudeが自動的に適切なエージェントを選びます。

```
このプロジェクトのセキュリティ脆弱性を確認してください
```

→ `security-reviewer` エージェントが自動選択される

**ポイント**: `description` が明確であるほど、正確に選択されます。

### 方法2: 明示的指定

エージェント名を指定して呼び出します。

```
code-reviewer エージェントを使って src/auth.ts をレビューしてください
```

または

```
@code-reviewer src/auth.ts をレビュー
```

**使用場面**:
- 複数の候補がある場合
- 自動選択が意図と違う場合
- 確実に特定エージェントを使いたい場合

---

## 実践的な設定例

### 例1: コードレビューエージェント

**ファイル**: `.claude/agents/code-reviewer.md`

```markdown
---
name: code-reviewer
description: TypeScript/Reactコードのセキュリティとパフォーマンスをレビューする
tools: Read, Grep, Glob
model: sonnet
---

# シニアコードレビューアー

あなたは10年以上のフルスタック開発経験を持つシニアエンジニアです。

## レビュー観点

### 1. セキュリティ（最優先）
- XSS脆弱性の有無
- 認証・認可の適切性
- 機密情報のハードコード
- 入力検証の不備

### 2. パフォーマンス
- React再レンダリング問題
- 不要なAPI呼び出し
- メモリリーク
- 非効率なアルゴリズム

### 3. 保守性
- 命名規則の一貫性
- コメントの適切性
- 関数の複雑度
- テストの有無

### 4. TypeScript型安全性
- any型の乱用
- 型アサーションの妥当性
- null/undefinedの適切な処理

## レビュー手順

1. 対象ファイルを読み込む
2. 関連ファイルを確認（import先など）
3. 上記4観点で分析
4. 重要度順にソート
5. レポート作成

## 出力形式

### 📊 サマリー
- Critical: X件
- High: Y件
- Medium: Z件

### [Critical] 問題タイトル
**ファイル**: `src/auth.ts:42`
**問題**: SQLインジェクション脆弱性
**詳細**: ユーザー入力をそのままクエリに埋め込んでいます
**対策**:
```typescript
// Before
const query = `SELECT * FROM users WHERE name = '${req.body.name}'`;

// After
const query = 'SELECT * FROM users WHERE name = ?';
db.execute(query, [req.body.name]);
```

## 制約

- ファイルは絶対に編集しない（読み取りのみ）
- 推測ではなく事実のみ報告
- コード例は必ず提示
```

---

### 例2: タスク分解エージェント

**ファイル**: `.claude/agents/task-decomposer.md`

```markdown
---
name: task-decomposer
description: 大規模な実装計画を単一コミットサイズのタスクに分解する
tools: Read
model: sonnet
---

# タスク分解スペシャリスト

## 役割

大きな機能実装を、コンテキストウィンドウに収まる小さなタスクに分解します。

## 分解の原則

1. **単一コミット原則**: 1タスク = 1つの独立した価値
2. **依存関係の明確化**: 順序が重要なタスクを特定
3. **テスト可能性**: 各タスクが個別にテスト可能
4. **ロールバック可能性**: 問題があれば1タスク単位で戻せる

## 分析手順

1. 要件ドキュメントを読み込む
2. 技術スタックを確認
3. 既存コードベースを理解
4. タスクを洗い出す
5. 依存関係を整理
6. 優先順位をつける

## 出力形式

### タスク一覧

#### タスク1: DB スキーマ作成
**優先度**: P0（最優先）
**依存**: なし
**見積もり**: 30分
**成果物**:
- `schema.sql`
- マイグレーションスクリプト

**詳細**:
users, posts, comments テーブルを作成

---

#### タスク2: API エンドポイント
**優先度**: P0
**依存**: タスク1
**見積もり**: 1時間
**成果物**:
- `/api/users` CRUD
- バリデーション

---

## 制約

- タスク数は最大10個まで（多すぎる場合はフェーズ分割）
- 各タスクは2時間以内で完了可能なサイズ
- 技術的負債は別タスクとして明示
```

---

### 例3: データベース列削除エージェント

**ファイル**: `.claude/agents/remove-column.md`

実際にZenn記事で紹介されていた実例です。

```markdown
---
name: remove-is-connected
description: データベースのis_connected列を安全に削除する
tools: Bash, Read, Edit, Glob, Grep
model: sonnet
---

# データベース列削除スペシャリスト

## ミッション

`is_connected` カラムをバックエンド、フロントエンド、テストから完全に削除します。

## 実行フェーズ

### フェーズ1: 影響範囲の特定
1. `is_connected` を使用している全ファイルを検索
2. 依存関係を分析
3. 変更が必要なファイルリストを作成

### フェーズ2: バックエンド修正（7ファイル）
1. モデル定義から削除
2. マイグレーションファイル作成
3. API レスポンスから除外
4. バリデーションルール更新

### フェーズ3: フロントエンド修正（2ファイル）
1. 型定義から削除
2. UI コンポーネントから削除

### フェーズ4: テスト修正（4ファイル）
1. テストデータから削除
2. アサーションを更新

### フェーズ5: 検証
1. Rubocop 実行
2. RSpec 実行
3. TypeScript コンパイル
4. すべてパスすることを確認

## 成功基準

- ✅ 全テストがパス
- ✅ Lint エラーなし
- ✅ `is_connected` への参照がゼロ

## トラブルシューティング

### テスト失敗時
- エラーメッセージを確認
- 該当ファイルを再確認
- 必要に応じて修正

### Lint エラー時
- Rubocop の提案に従う
- ESLint の警告を解決

## 制約

- データベースのマイグレーションは慎重に
- バックアップなしで実行しない
- 本番環境では実行前に必ずステージング検証
```

---

## トラブルシューティング

### 問題1: エージェントが表示されない

**症状**: `/agents` で作成したエージェントが見えない

**原因**:
- ファイル名が間違っている
- YAMLフロントマターの構文エラー
- 保存場所が間違っている

**解決策**:

```bash
# 1. ファイルの存在確認
ls -la .claude/agents/
ls -la ~/.claude/agents/

# 2. YAML構文チェック
cat .claude/agents/your-agent.md

# 3. Claude Code再起動
# VSCodeの場合: Reload Window
```

**Zenn記事のTips**:
> 「エージェントが突然表示されなくなった場合、新しいエージェントを1つ作成するか、セッションを再起動すると再発見される」

---

### 問題2: 自動選択されない

**症状**: 適切なタスクなのにエージェントが選ばれない

**原因**: `description` が曖昧

**解決策**:

```yaml
# ❌ 悪い例
description: コードを確認する

# ✅ 良い例
description: TypeScriptファイルのセキュリティ脆弱性とパフォーマンス問題を検出し、具体的な改善コードを提示する
```

---

### 問題3: 意図しない動作

**症状**: エージェントが予期しない操作をする

**原因**: `tools` の制限が不十分

**解決策**:

```yaml
# ❌ 危険
tools:  # 全て継承

# ✅ 安全
tools: Read, Grep  # 読み取りのみ
```

---

### 問題4: 同名エージェントの競合

**症状**: プロジェクトとユーザーレベルに同名エージェントがある

**優先順位**:
1. プロジェクトレベル (`.claude/agents/`)
2. ユーザーレベル (`~/.claude/agents/`)

**解決策**:
- プロジェクト固有のものはプロジェクトレベルに
- 汎用的なものはユーザーレベルに
- 同名を避ける（`project-code-reviewer` vs `general-code-reviewer`）

---

## ベストプラクティス

### 1. バージョン管理

プロジェクトレベルのエージェントはGitで管理します。

```bash
# .gitignore に追加しない
# .claude/agents/ をコミット

git add .claude/agents/
git commit -m "Add code-reviewer subagent"
git push
```

**利点**:
- チーム全体で共有
- 変更履歴の追跡
- レビュー可能

---

### 2. ドキュメント化

各エージェントにREADMEを用意します。

**ファイル**: `.claude/agents/README.md`

```markdown
# プロジェクトのサブエージェント

## エージェント一覧

### code-reviewer
- **用途**: コードレビュー
- **使い方**: `code-reviewer を使って src/ をレビュー`
- **制限**: 読み取りのみ

### test-automation
- **用途**: テスト自動修正
- **使い方**: Git Hook で自動起動
- **制限**: 編集・実行可能

## 追加方法

1. `create-agent.sh` を実行
2. テンプレートを編集
3. チームレビュー後にマージ
```

---

### 3. テスト

エージェントも「コード」です。テストしましょう。

```markdown
## テストシナリオ

### 正常系
1. サンプルファイルを用意
2. エージェントを実行
3. 期待する出力を確認

### 異常系
1. 不正なファイルパス
2. 空のファイル
3. 権限エラー

### エッジケース
1. 巨大ファイル
2. 多言語ファイル
3. バイナリファイル
```

---

### 4. 段階的な権限付与

最初は制限的に、必要に応じて拡張します。

```yaml
# フェーズ1: 分析のみ
tools: Read, Grep

# フェーズ2: レポート作成
tools: Read, Grep, Write

# フェーズ3: 修正も可能に
tools: Read, Grep, Write, Edit

# フェーズ4: 実行も許可
tools: Read, Grep, Write, Edit, Bash
```

---

### 5. モデルの使い分け

コストと性能のバランスを考えます。

```yaml
# 軽量タスク → Haiku
---
name: server-starter
model: haiku
---

# 通常タスク → Sonnet（デフォルト）
---
name: code-reviewer
model: sonnet
---

# 高度な推論 → Opus
---
name: architecture-designer
model: opus
---
```

---

## まとめ

このドキュメントで学んだこと:

✅ **3つの作成方法**: `/agents`コマンド、ファイル直接作成、CLI
✅ **4つの設定項目**: name, description, tools, model
✅ **2つの呼び出し方**: 自動選択、明示的指定
✅ **実践的な設定例**: レビュー、タスク分解、DB操作
✅ **トラブルシューティング**: よくある問題と解決策
✅ **ベストプラクティス**: バージョン管理、テスト、段階的権限付与

---

### 次のステップ

設定方法を理解しました。

次のドキュメント「[03_prompt-optimization-techniques.md](03_prompt-optimization-techniques.md)」では、**サブエージェントのプロンプトを自動的に最適化する高度な技術**を学びます。

---

**参考資料**:
- [Claude Code 公式ドキュメント - Sub-agents](https://code.claude.com/docs/ja/sub-agents)
- [雑に理解する Claude Code サブエージェント - Zenn](https://zenn.dev/mach3/articles/30ba24f4365fe0)
- [Claude Code の勝手な処理を防止 - Zenn](https://zenn.dev/sfitb/articles/dd95769c191df7)
